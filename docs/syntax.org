#+title: Tangi Syntax
* File
A file is the second biggest unit of compilation, that is also sometimes called a =module=.
You could import files by using the ~import~ function and assigning it to a const, like this:

#+begin_example tangi
const parser = import("frontend/parser.tn");
#+end_src

* Item
** Function
A function is a function
*** Block
A block is a block containing multiple statements, that could also be expressions.
**** Statement
***** Return statement
A return statement is a statement that, if reached, stops execution of current block,
and returns the specified value (like in ~return 128~ 128 is the return value),
or ~void~, if no return value is specified. (like ~return~)
***** If statement
An if statement has different styles:
- Quick
  ~if condition => return~
- Rust style
  ~if condition { return }~
- C style
  ~if (condition) return~
All of them have the same functionality

("breaking barriers", literally)
***** Let statement
A let statement lets (haha because ~let~ hahahaha) you declare
a variable, optionally making it mutable by declaring it with ~let mut~.

#+begin_example tangi
let mut something = true;
#+end_example

You could also declare it with a type, although usually it is inferred.
#+begin_example tangi
let variable: i32 = -18;
#+end_example

If you declare a variable with ~const const const const~, you will just disintegrate the value.
#+begin_example tangi
const const const const help = 0;
#+end_example
If you use ~const const const const~ with a ~Copy~ value, you will get a compile error because fuck you.
The above example will error, because it disintegrates a ~Copy~ value.

****** Variable redeclaration
In Tangi, you could redeclare variables.
Also used with the ~const const const const~ syntax to disintegrate a function parameter or otherwise unused variable.
#+begin_example tangi
fn hello(remy_clarke: RemyClarke, int: i32) {
    // disintegrates `remy_clarke`
    const const const const remy_clarke;
    // redeclares `int` as a mutable `i32`, giving it the value of the function param `int`
    let mut int;
    // ==
    let mut int: i32 = int;
}
#+end_exmaple
***** For statement and other loops
The ~for~ statement lets you loop over the contents of a value implementing ~Iterator~.

#+begin_example tangi
// compile error - int too large
for (0..190238102381283018230182380180923890128903189023980129803 as h) {
    std.debug.eprintln("{}", h);
}
#+end_example
* Types
** Error union
An error union is a type, that contains either an error, or another ("happy path", if you prefer) value.
An error union type is declared like this:
#+begin_example tangi
ErrorEnum!HappyValue
#+end_example

An error union could have its' error type inferred (i.e. left out like ~!HappyValue~),
if it is consistent across the whole function and it implements the ~Error~ trait.
The "happy path" type cannot implement ~Error~
when the error type is inferred (as it would conflict with inference).
